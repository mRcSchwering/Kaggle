---
title: "Housing Cri.. Prices"
subtitle: "Data Exploration"
author: "Marc Schwering"
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 2
    fig_width: 10
    fig_height: 7
    theme: cosmo
---







# Introduction



**Loading Data**

The following libraries will be used.

```{r, message=FALSE, warning=FALSE, results='hide'}
library(data.table) # database-like tables
library(ggplot2) # general plots
library(DT) # display tables
library(corrplot) # corr SPLOMs
library(vcd) # stats for categories
library(mice) # for imputation
```

Input is loaded and covnerted to `data.table`.

```{r}
test <- read.csv("../input/test.csv")
train <- read.csv("../input/train.csv")
test <- data.table(test)
train <- data.table(train)
```








***







# Data Quality

The number of dimensions and density of the input matrix is calculated.
The datasets are combined.

```{r}
(N <- nrow(train))
(p <- ncol(train) - 2)
N^(1/p)
test$SalePrice <- NaN
full <- rbind(train, test)
```

## Feature Attributes

From the *data_description* variable types can be defined.
There are 4 categories: *nominal*, *ordinal*, *discrete*, *continuous*.
A lot of the discrete variables could arguably be handled as ordinals.

```{r}
nomVars <- c("MSZoning", "Street", "Alley", "LandContour", "LotConfig",
             "Neighborhood", "Condition1", "Condition2", "HouseStyle",
             "RoofStyle", "RoofMatl", "Exterior1st", "Exterior2nd",
             "MasVnrType", "Foundation", "Heating", "CentralAir", "Electrical",
             "GarageType", "PavedDrive", "MiscFeature", "SaleType",
             "SaleCondition")
ordVars <- c("MSSubClass", "LotShape", "Utilities", "LandSlope", "BldgType",
             "OverallQual", "OverallCond", "ExterQual", "ExterCond", "BsmtQual",
             "BsmtCond", "BsmtExposure", "BsmtFinType1", "BsmtFinType2",
             "HeatingQC", "KitchenQual", "Functional", "FireplaceQu",
             "GarageFinish", "GarageQual", "GarageCond", "PoolQC", "Fence",
             "MoSold")
discVars <- c("YearBuilt", "YearRemodAdd", "BsmtFullBath", "BsmtHalfBath",
              "FullBath", "HalfBath", "BedroomAbvGr", "KitchenAbvGr",
              "TotRmsAbvGrd", "Fireplaces", "GarageYrBlt", "GarageCars",
              "YrSold")
contVars <- c("LotArea", "MasVnrArea", "BsmtFinSF1", "BsmtFinSF2", "BsmtUnfSF",
              "TotalBsmtSF", "X1stFlrSF", "X2ndFlrSF", "LowQualFinSF",
              "GrLivArea", "GarageArea", "WoodDeckSF", "OpenPorchSF",
              "EnclosedPorch", "X3SsnPorch", "ScreenPorch", "PoolArea",
              "MiscVal", "LotFrontage")
```

A table is created to store feature attributes.

```{r, results='hide'}
featAttr <- data.table(
  name = colnames(test)[-1],
  type = "nominal"
)
featAttr[name %in% ordVars, type := "ordinal"]
featAttr[name %in% discVars, type := "discrete"]
featAttr[name %in% contVars, type := "continuous"]
```

**Special Values**

According to *data_description* several $NA$ have a special meaning.
These values are replaced with more descriptive `chr` strings.
Before, test and train set are combined.

```{r, results='hide', message=FALSE}
full$label <- rep(c("train", "test"), c(nrow(test), nrow(train)))
full[is.na(Alley), Alley := "noAccess"]
full[is.na(BsmtQual), BsmtQual := "noBasement"]
full[is.na(BsmtCond), BsmtCond := "noBasement"]
full[is.na(BsmtExposure), BsmtExposure := "noBasement"]
full[is.na(BsmtFinType1), BsmtFinType1 := "noBasement"]
full[is.na(BsmtFinType2), BsmtFinType2 := "noBasement"]
full[is.na(FireplaceQu), FireplaceQu := "noFireplace"]
full[is.na(GarageType), GarageType := "noGarage"]
full[is.na(GarageFinish), GarageFinish := "noGarage"]
full[is.na(GarageQual), GarageQual := "noGarage"]
full[is.na(GarageCond), GarageCond := "noGarage"]
full[is.na(PoolQC) , PoolQC := "noPool"]
full[is.na(Fence), Fence := "noFence"]
full[is.na(MiscFeature), MiscFeature := "none"]
```

Nominal, ordinal, and discrete variables are converted to `factor`,
continuous to `numeric`.

```{r}
for (j in c(nomVars, ordVars, discVars)) full[[j]] <- as.factor(full[[j]])
for (j in contVars) full[[j]] <- as.numeric(full[[j]])
```

**Ordering**

From *data_description* the order of ordinal variable classes can be derived.
These orderings are defined, then the `levels` of their `factors` are adjusted.

```{r}
lvlOrd <- list(
  LotShape = c("Reg", "IR1", "IR2", "IR3"),
  Utilities = c("AllPub", "NoSewr", "NoSeWa", "ELO"),
  LandSlope = c("Gtl", "Mod", "Sev"),
  BldgType = c("1Fam", "2FmCon", "Duplx", "TwnhsE", "TwnhsI"),
  OverallQual = 10:1,
  OverallCond = 10:1,
  ExterQual = c("Ex", "Gd", "TA", "Fa", "Po"),
  ExterCond = c("Ex", "Gd", "TA", "Fa", "Po"),
  BsmtQual = c("Ex", "Gd", "TA", "Fa", "Po", "noBasement"),
  BsmtCond = c("Ex", "Gd", "TA", "Fa", "Po", "noBasement"),
  BsmtExposure = c("Gd", "Av", "Mn", "No", "noBasement"),
  BsmtFinType1 = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "noBasement"),
  BsmtFinType2 = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "noBasement"),
  HeatingQC = c("Ex", "Gd", "TA", "Fa", "Po"),
  KitchenQual = c("Ex", "Gd", "TA", "Fa", "Po"),
  Functional = c("Typ", "Min1", "Min2", "Mod", "Maj1", "Maj2", "Sev", "Sal"),
  FireplaceQu = c("Ex", "Gd", "TA", "Fa", "Po", "noFireplace"),
  GarageFinish = c("Fin", "RFn", "Unf", "noGarage"),
  GarageQual = c("Ex", "Gd", "TA", "Fa", "Po", "noGarage"),
  GarageCond = c("Ex", "Gd", "TA", "Fa", "Po", "noGarage"),
  PoolQC = c("Ex", "Gd", "TA", "Fa", "noPool"),
  Fence = c("GdPrv", "MnPrv", "GdWo", "MnWw", "noFence"),
  MoSold = 1:12
)
for (j in names(lvlOrd)) {
  full[[j]] <- factor(full[[j]], levels = lvlOrd[[j]])
}
```

## Feature Dependencies

Some features' values heavily depend on the value of another feature.
For example the values of $BsmtUnfSF$, $TotalBsmtSF$ only make sense if
features $BsmtCond$, $BsmtExposure$, $BsmtQual$ are not $noBasement$.
This information is given in *data_description*.

$$
\begin{aligned}
BsmtUnfSF, TotalBsmtSF : BsmtCond, BsmtExposure, BsmtQual \ne noBasement\\
BsmtFinSF1 : BsmtFinType1 \ne noBasement\\
BsmtFinSF2 : BsmtFinType2 \ne noBasement \\
GarageYrBlt, GarageCars, GarageArea: GarageType, GarageFinish, GarageQual, 
GarageCond \ne noGarage \\
PoolArea : PoolQC \ne noPool \\
MiscVal : MiscFeature \ne none \\
MasVnrArea : MasVnrType \ne none
\end{aligned}
$$
For the garage and basement features there are several features which indicate
the absence of that feature.
If one of them indicates the absence of a feature, the others should too.

```{r}
setdiff(which(full$BsmtCond == "noBasement"),
          which(full$BsmtExposure == "noBasement"))
setdiff(which(full$BsmtCond == "noBasement"),
          which(full$BsmtQual == "noBasement"))
full[c(2041, 2186, 2525), .(Id, BsmtCond, BsmtExposure, BsmtQual, 
                            BsmtUnfSF, TotalBsmtSF)]
```

So here the *data_description* is not consistent.
The general condition is set to *noBasement* but there are values
for basement exposure, quality, and so on.

```{r}
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageFinish == "noGarage"))
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageQual == "noGarage"))
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageCond == "noGarage"))
```

The garage features doesn't have these inconsistencies.

**Mark Undefined Variables**

If e.g. *PoolQC* is *noPool*, then there should be a missing vlaue or
a zero for *PoolArea*.
If there actually is a value, this could either mean it is a mistake
or it means something special that is not clearly described.
To at least be consistent, all *NA*s will be set to 0.

```{r, results='hide'}
full[BsmtCond == "noBasement" & is.na(BsmtUnfSF), BsmtUnfSF := 0]
full[BsmtCond == "noBasement" & is.na(TotalBsmtSF), TotalBsmtSF := 0]
full[BsmtFinType1 == "noBasement" & is.na(BsmtFinSF1), BsmtFinSF1 := 0]
full[BsmtFinType2 == "noBasement" & is.na(BsmtFinSF2), BsmtFinSF2 := 0]
full[GarageType == "noGarage" & is.na(GarageYrBlt), GarageYrBlt := "0"]
full[GarageType == "noGarage" & is.na(GarageCars), GarageCars := "0"]
full[GarageType == "noGarage" & is.na(GarageArea), GarageArea := 0]
full[PoolQC == "noPool" & is.na(PoolArea), PoolArea := 0]
full[MiscFeature == "noFeature" & is.na(MiscVal), MiscVal := 0]
```






## Missing Data

$NA$ which are left must be true missing data.

```{r}
naFeats <- apply(full[, !"SalePrice"], 2, function(x) any(is.na(x)))
naObs <- apply(full[, !"SalePrice"], 1, function(x) any(is.na(x)))
```

**Features**

The total number of missing values per feature will be saved.
The features with at least one missing value are shown below.

```{r}
total <- apply(full[, naFeats, with = FALSE], 2, function(j) sum(is.na(j)))
df <- data.frame(
  missing = total / nrow(full),
  name = factor(names(total), levels = names(total)[order(total)]),
  type = featAttr[match(names(total), featAttr$name), type]
)
ggplot(df, aes(x = name, y = missing, fill = type)) +
  geom_bar(stat = "identity") +
  scale_y_continuous("proportion missing") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Features with Missing Values")
```

**Observations**

Below the number of missing values for observations that have missing values
is shown.
Many observations have 1 or 2, some have 3 or 4 missing values.

```{r}
total <- apply(full[naObs, ], 1, function(i) sum(is.na(i)))
df <- data.frame(
  y = total,
  name = full[naObs, Id]
)
highchart() %>%
    hc_chart(type = "column") %>%
    hc_title(text = "Observations with Missing Values") %>%
    hc_xAxis(title = list(text = "observations"), categories = df$name, 
             labels  = list(rotation = "-45")) %>%
    hc_yAxis(title = list(text = "missing"), align = "left") %>%
    hc_add_series(showInLegend = FALSE, data = list_parse(df[order(df$y), ]))
```













***



















# Feature Exploration


## Feature Distributions

Feature distributions are described for each type of variable separately.

### Continuous Variables

Values were log10 transformed to better capture their spread.
There are many zeros, partly because of the dependency to another variable.
These zeros are excluded during the transformation.

```{r, fig.width=10, fig.height=10, warning=FALSE}
dt <- melt(full, "Id", contVars)
ggplot(dt, aes(x = value)) +
  geom_histogram(bins = 30) +
  scale_x_continuous(trans = "log10") +
  facet_wrap(~ variable, scale = "free") +
  theme_bw()
```

Summaries for each distribution are computed.
There are many undefined variables which are set to zero.
This influences the description a lot.
Therefore, they are excluded.

```{r}
dt <- full[, contVars, with = FALSE]
df <- data.frame(
  Min = apply(dt, 2, function(x) min(x[x > 0], na.rm = TRUE)),
  Mean = apply(dt, 2, function(x) mean(x[x > 0], na.rm = TRUE)),
  Median = apply(dt, 2, function(x) median(x[x > 0], na.rm = TRUE)),
  Max = apply(dt, 2, function(x) max(x[x > 0], na.rm = TRUE))
)
```

Relative difference between mean and median (*relDelta*) are computed as an
indicator for skewness.
Also, relative cardinality and relative number of outliers are computed.
Outliers are defined as being differing at least $+/- 1.5 MAD$ from the median.

```{r}
df$relDelta <- abs(df$Mean - df$Median) / df$Mean
df$relCard <- apply(dt, 2, function(x) {
  length(unique(x[x > 0])) / length(x[x > 0])
})
df$relOut <- apply(dt, 2, function(x) {
  length(boxplot.stats(x[x > 0])$out) / length(x[x > 0])
})
```

*PoolArea* and *MiscVal* show a high proportion of outliers,
but this might be because there are not many total values for these variables.
Many supposably continuous variables have a quite low cardinality.

```{r}
DT::datatable(df, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle('relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))) %>%
  formatStyle('relCard', 
    color = styleInterval(c(0.2, 0.6), c('red', 'orange', 'green'))) %>%
  formatStyle('relOut', 
    color = styleInterval(c(0.05, 0.1), c('green', 'orange', 'red'))) %>%
  formatRound(c(2, 5:7), 3)
```



### Discrete Variables

Distributions are shown below.

```{r, fig.width=10, fig.height=10, warning=FALSE}
dt <- melt(full, "Id", discVars)
ggplot(dt, aes(x = value)) +
  geom_bar() +
  facet_wrap(~ variable, scales = "free") +
  theme_bw()
```

As summary, the value range, mean and median of the categorical
distribution, and cardinality are computed.

```{r}
dt <- full[, discVars, with = FALSE]
df <- data.frame(
  Min = apply(dt, 2, function(x) min(as.numeric(as.character(x)), na.rm = TRUE)),
  Max = apply(dt, 2, function(x) max(as.numeric(as.character(x)), na.rm = TRUE)),
  MeanCount = apply(dt, 2, function(x) mean(table(x[!is.na(x)]))),
  MedianCount = apply(dt, 2, function(x) median(table(x[!is.na(x)]))),
  Card = apply(dt, 2, function(x) length(unique(x[!is.na(x)])))
)
```

Relative difference between mean and median count (*relDelta*) are 
computed as an indicator for skewness.
Outliers in categorical distribution are detected.

```{r}
df$relDelta <- abs(df$MeanCount - df$MedianCount) / df$MeanCount
df$relOut <- apply(dt, 2, function(x) {
  length(boxplot.stats(table(x[!is.na(x)]))$out) / length(x[!is.na(x)])
})
```

Actually, *relDelta* and outliers are only interesting for the *year* variables 
where there is a high cardinality.

```{r}
DT::datatable(df, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle('relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))) %>%
  formatStyle('relOut', 
    color = styleInterval(c(0.05, 0.1), c('green', 'orange', 'red'))) %>%
  formatRound(c(3, 6:7), 3)
```




### Categorical Variables

**Ordinal Variables**

```{r, fig.width=10, fig.height=10, warning=FALSE}
dt <- melt(full, "Id", ordVars)
ggplot(dt, aes(x = value)) +
  geom_bar() +
  facet_wrap(~ variable, scales = "free") +
  theme_bw()
```

**Nominal Variables**

```{r, fig.width=10, fig.height=10, warning=FALSE}
dt <- melt(full, "Id", nomVars)
ggplot(dt, aes(x = value)) +
  geom_bar() +
  facet_wrap(~ variable, scales = "free") +
  theme_bw()
```


**Summary**

```{r}
dt <- full[, c(ordVars, nomVars), with = FALSE]
df <- data.frame(
  MeanCount = apply(dt, 2, function(x) mean(table(x[!is.na(x)]))),
  MedianCount = apply(dt, 2, function(x) median(table(x[!is.na(x)]))),
  Card = apply(dt, 2, function(x) length(unique(x[!is.na(x)]))),
  Type = rep(c("ord", "nom"), c(length(ordVars), length(nomVars)))
)
```

The indicators from above don't make much sense for these.

```{r}
DT::datatable(df, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle('Type', 
    color = styleEqual(unique(df$Type), c('orange', 'blue'))) %>%
  formatRound(1, 3)
```














Discrete features will be included in both categorical and continuous feature
analysis.

## Continuous

### Feature Distributions

The following table gives a descriptive overview about continuous and discrete
feature distributions.
Besides the range and averages of variables, the relative difference between
mean and median is given as an indicator of the skewness.
In addition the relative cardinality and the abundance of outliers are given.

```{r}
vars <- c(contVars, discVars)
m <- apply(full[, vars, with = FALSE], 2,
      function(j) summary(as.numeric(as.character(j)))[c(1, 3, 4, 6)])
cards <- c(featAttr[type == "continuous", card], 
           featAttr[type == "discrete", card])
outs <- apply(full[, vars, with = FALSE], 2, 
              function(j) length(boxplot.stats(j)$out) / length(j))
dt <- data.table(t(m))
dt$relDelta <- round((dt$Mean - dt$Median) / dt$Mean, 2)
dt$relCard <- round(cards, 2)
dt$relOuts <- round(outs, 2)
rownames(dt) <- vars
dt$type <- rep(c("cont", "disc"), c(length(contVars), length(discVars)))
DT::datatable(dt, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle(
    'relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'relCard', 
    color = styleInterval(c(0.2, 0.6), c('red', 'orange', 'green'))
  ) %>%
  formatStyle(
    'relOuts', 
    color = styleInterval(c(0.05, 0.1), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'type', 
    color = styleEqual(unique(dt$type), c('orange', 'blue'))
  )
```

In *GarageYrBlt* the maximum value is 2207, which does not make sense.
It seems that this is a type and the real value is 2007.
After checking that there are not more values above 2010
2207 is changed to 2007.

```{r, results='hide'}
full[GarageYrBlt == 2207, GarageYrBlt := 2007]
```

There are a lot of continuous features with low cardinality and a high
difference between mean and median.
All these variables have a median of 0.
Some of these variables are dependent on other categorical variables, 
so it is plausible that they are sparse.


### Correlatio between Features

The Pearson Correlation Coefficient is calculated for all feature pairs
where both features are discrete or continous.
The results are shown as heatmap below.
Using euclidean distance of the correlation matrix as a metric 
rows and columns were hierarchically ordered (complete link).

```{r, fig.width=10, fig.height=10}
m <- cor(
  full[, vars, with = FALSE],
  use = "complete.obs"
)
corrplot(m, method = "color", order = "hclust")
```

Some clusters are visible.
The same hierarchical clustering is shown as tree below.

```{r}
corrClust <- hclust(dist(m))
plot(corrClust)
```


### Correlation to Target

For all continuous features the pearson correlation coefficient
to the target *SalePrice* is calculated.
Results are ordered by correlation.
The color labels the feature type, continuous or discrete.

```{r, fig.width=10, fig.height=5}
train <- full[label == "train", !"label", with = FALSE]
cors <- vapply(
  vars,
  function(i) cor(train[[i]], train$SalePrice, use = "complete.obs"),
  numeric(1)
)
df <- data.frame(
  var = factor(vars, levels = vars[order(cors)]),
  cor = cors,
  type = rep(c("cont", "disc"), c(length(contVars), length(discVars)))
)
ggplot(df, aes(x = var, y = cor, fill = type)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("P Correl Coeff of Cont+Disc Features vs SalePrice")
```








## Categorical

### Feature Distributions

As an overview of these features their 
categorical distribution is described.
The table below summarizes range and averages, as well as the relative
difference between mean and median (*relDalta*).

```{r}
vars <- c(discVars, ordVars, nomVars)
m <- apply(full[, vars, with = FALSE], 2, 
           function(j) summary(as.vector(table(j)))[c(1, 3, 4, 6)])
dt <- data.table(t(m))
dt$relDelta <- round((dt$Mean - dt$Median) / dt$Mean, 2)
dt$type <- rep(c("disc", "ord", "nom"), 
               c(length(discVars), length(ordVars), length(nomVars)))
rownames(dt) <- vars
DT::datatable(dt, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle(
    'relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'type', 
    color = styleEqual(unique(dt$type), c('orange', 'blue', 'pink'))
  )
```

For most variables there is a big difference in the frequency of
classes that can occur.
There is no feature where a class can be completely excluded, 
but there are some features which have classes with only one representation.









### Correlation between Features

The Cramer's V is calculated for all feature pairs
where both features are categories.
The results are shown as heatmap below.
Using euclidean distance of the correlation matrix as a metric 
rows and columns were hierarchically ordered (complete link).

```{r, fig.width=10, fig.height=10, warning=FALSE}
m <- as.matrix(full[, vars, with = FALSE])
m <- m[complete.cases(m), ]
mCramer <- vapply(
  seq_len(ncol(m)),
  function(i) {
    vapply(
      seq_len(ncol(m)),
      function(j) {
        assocstats(table(m[, i], m[, j]))$cramer
      },
      numeric(1)
    )
  },
  numeric(ncol(m))
)
colnames(mCramer) <- colnames(m)
rownames(mCramer) <- colnames(m)
corrplot(mCramer, method = "color", order = "hclust")
```

The same hierarchical clustering is shown as tree below.

```{r}
corrClust <- hclust(dist(mCramer))
plot(corrClust)
```

### Correlation to Target

For all categorical features the Kruskal-Wallis $\chi^2$ statistic
to the target *SalePrice* is calculated.
Results are ordered by the $\chi^2$ value.
The color labels the feature type, nominal or ordinal.

```{r, fig.width=10, fig.height=5, warning=FALSE}
kwX2 <- vapply(
  vars,
  function(j) { kruskal.test(train$SalePrice, train[[j]])$statistic },
  numeric(1)
)
df <- data.frame(
  var = factor(vars, levels = vars[order(kwX2)]),
  kwX2 = kwX2,
  type = rep(c("disc", "ord", "nom"), c(length(discVars), length(ordVars), length(nomVars)))
)
ggplot(df, aes(x = var, y = kwX2, fill = type)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("KW-X^2 for Categories+Disc Feats vs SalePrice")
```







***






# Imputation

Featrues with missing values are.

```{r}
featAttr[missing > 0, ]
```

Imputation methods are defined.

```{r}
featAttr$impMethod <- ""
```

Continuous variables should be imputed using predictive mean matching,
binary variables using logistic regression,
other discrete and ordinal variables using proportional odds,
others using polytomous regression.

```{r, results='hide'}
featAttr[missing > 0, impMethod := "polyreg"]
featAttr[missing > 0 & type == "ordinal", impMethod := "polr"]
featAttr[missing > 0 & type == "discrete", impMethod := "polr"]
featAttr[missing > 0 & card == 2, impMethod := "logreg"]
featAttr[missing > 0 & type == "continuous", impMethod := "pmm"]
```



```{r}
imp <- mice(full, method = c("", featAttr$impMethod, ""))
imp <- mice(full)
```



```{r}
imp <- mice(full[, .(Utilities)])
str(full)
unique(full$Utilities)

imp <- mice(full, seed = 42)
?mice


```

