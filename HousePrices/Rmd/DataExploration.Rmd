---
title: "Housing Cri.. Prices"
subtitle: "Data Exploration"
author: "Marc Schwering"
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 2
    fig_width: 10
    fig_height: 7
    theme: cosmo
---







# Introduction



**Loading Data**

The following libraries will be used.

```{r, message=FALSE, warning=FALSE, results='hide'}
library(data.table) # database-like tables
library(ggplot2) # general plots
library(DT) # display tables
library(fitdistrplus) # fit distributions
library(corrplot) # corr SPLOMs
library(vcd) # stats for categories
library(mice) # for imputation
```

Input is loaded and covnerted to `data.table`.

```{r}
test <- read.csv("../input/test.csv")
train <- read.csv("../input/train.csv")
test <- data.table(test)
train <- data.table(train)
```








***







# Data Quality

The number of dimensions and density of the input matrix is calculated.

```{r}
(N <- nrow(train))
(p <- ncol(train) - 2)
N^(1/p)
```

## Variable Types

From the *data_description* variable types can be defined.
There are 4 categories: *nominal*, *ordinal*, *discrete*, *continuous*.

```{r}
nomVars <- c("MSZoning", "Street", "Alley", "LandContour", "LotConfig",
             "Neighborhood", "Condition1", "Condition2", "HouseStyle",
             "RoofStyle", "RoofMatl", "Exterior1st", "Exterior2nd",
             "MasVnrType", "Foundation", "Heating", "CentralAir", "Electrical",
             "GarageType", "PavedDrive", "MiscFeature", "SaleType",
             "SaleCondition")
ordVars <- c("MSSubClass", "LotShape", "Utilities", "LandSlope", "BldgType",
             "OverallQual", "OverallCond", "ExterQual", "ExterCond", "BsmtQual",
             "BsmtCond", "BsmtExposure", "BsmtFinType1", "BsmtFinType2",
             "HeatingQC", "KitchenQual", "Functional", "FireplaceQu",
             "GarageFinish", "GarageQual", "GarageCond", "PoolQC", "Fence",
             "MoSold")
discVars <- c("YearBuilt", "YearRemodAdd", "BsmtFullBath", "BsmtHalfBath",
              "FullBath", "HalfBath", "BedroomAbvGr", "KitchenAbvGr",
              "TotRmsAbvGrd", "Fireplaces", "GarageYrBlt", "GarageCars",
              "YrSold")
contVars <- c("LotArea", "MasVnrArea", "BsmtFinSF1", "BsmtFinSF2", "BsmtUnfSF",
              "TotalBsmtSF", "X1stFlrSF", "X2ndFlrSF", "LowQualFinSF",
              "GrLivArea", "GarageArea", "WoodDeckSF", "OpenPorchSF",
              "EnclosedPorch", "X3SsnPorch", "ScreenPorch", "PoolArea",
              "MiscVal", "LotFrontage")
```

A table is created to store feature attributes.

```{r, results='hide'}
featAttr <- data.table(
  name = colnames(test)[-1],
  type = "nominal"
)
featAttr[name %in% ordVars, type := "ordinal"]
featAttr[name %in% discVars, type := "discrete"]
featAttr[name %in% contVars, type := "continuous"]
```


## Special Values

According to *data_description* several $NA$ have a special meaning.
These values are replaced with more descriptive `chr` strings.
Before, test and train set are combined.

```{r, results='hide', message=FALSE}
test$SalePrice <- NaN
full <- rbind(train, test)
full$label <- rep(c("train", "test"), c(nrow(test), nrow(train)))
full[is.na(Alley), Alley := "noAccess"]
full[is.na(BsmtQual), BsmtQual := "noBasement"]
full[is.na(BsmtCond), BsmtCond := "noBasement"]
full[is.na(BsmtExposure), BsmtExposure := "noBasement"]
full[is.na(BsmtFinType1), BsmtFinType1 := "noBasement"]
full[is.na(BsmtFinType2), BsmtFinType2 := "noBasement"]
full[is.na(FireplaceQu), FireplaceQu := "noFireplace"]
full[is.na(GarageType), GarageType := "noGarage"]
full[is.na(GarageFinish), GarageFinish := "noGarage"]
full[is.na(GarageQual), GarageQual := "noGarage"]
full[is.na(GarageCond), GarageCond := "noGarage"]
full[is.na(PoolQC) , PoolQC := "noPool"]
full[is.na(Fence), Fence := "noFence"]
full[is.na(MiscFeature), MiscFeature := "none"]
```

Nominal and ordinal variables are converted to `factor`,
continuous and discrete to `numeric` and `integer` respectively.

```{r}
for (j in c(nomVars, ordVars)) full[[j]] <- as.factor(full[[j]])
for (j in discVars) full[[j]] <- as.integer(full[[j]])
for (j in contVars) full[[j]] <- as.numeric(full[[j]])
```

## Ordering

From *data_description* the order of ordinal variable classes can be derived.
These orderings are defined, then the `levels` of their `factors` are adjusted.

```{r}
lvlOrd <- list(
  LotShape = c("Reg", "IR1", "IR2", "IR3"),
  Utilities = c("AllPub", "NoSewr", "NoSeWa", "ELO"),
  LandSlope = c("Gtl", "Mod", "Sev"),
  BldgType = c("1Fam", "2FmCon", "Duplx", "TwnhsE", "TwnhsI"),
  OverallQual = 10:1,
  OverallCond = 10:1,
  ExterQual = c("Ex", "Gd", "TA", "Fa", "Po"),
  ExterCond = c("Ex", "Gd", "TA", "Fa", "Po"),
  BsmtQual = c("Ex", "Gd", "TA", "Fa", "Po", "noBasement"),
  BsmtCond = c("Ex", "Gd", "TA", "Fa", "Po", "noBasement"),
  BsmtExposure = c("Gd", "Av", "Mn", "No", "noBasement"),
  BsmtFinType1 = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "noBasement"),
  BsmtFinType2 = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "noBasement"),
  HeatingQC = c("Ex", "Gd", "TA", "Fa", "Po"),
  KitchenQual = c("Ex", "Gd", "TA", "Fa", "Po"),
  Functional = c("Typ", "Min1", "Min2", "Mod", "Maj1", "Maj2", "Sev", "Sal"),
  FireplaceQu = c("Ex", "Gd", "TA", "Fa", "Po", "noFireplace"),
  GarageFinish = c("Fin", "RFn", "Unf", "noGarage"),
  GarageQual = c("Ex", "Gd", "TA", "Fa", "Po", "noGarage"),
  GarageCond = c("Ex", "Gd", "TA", "Fa", "Po", "noGarage"),
  PoolQC = c("Ex", "Gd", "TA", "Fa", "noPool"),
  Fence = c("GdPrv", "MnPrv", "GdWo", "MnWw", "noFence"),
  MoSold = 1:12
)
for (j in names(lvlOrd)) {
  full[[j]] <- factor(full[[j]], levels = lvlOrd[[j]])
}
```

## Feature Dependencies

Some features' values heavily depend on the value of another feature.
For example the values of $BsmtUnfSF$, $TotalBsmtSF$ only make sense if
features $BsmtCond$, $BsmtExposure$, $BsmtQual$ are not $noBasement$.
This information is given in *data_description*.

$$
\begin{aligned}
BsmtUnfSF, TotalBsmtSF : BsmtCond, BsmtExposure, BsmtQual \ne noBasement\\
BsmtFinSF1 : BsmtFinType1 \ne noBasement\\
BsmtFinSF2 : BsmtFinType2 \ne noBasement \\
GarageYrBlt, GarageCars, GarageArea: GarageType, GarageFinish, GarageQual, 
GarageCond \ne noGarage \\
PoolArea : PoolQC \ne noPool \\
MiscVal : MiscFeature \ne none \\
MasVnrArea : MasVnrType \ne none
\end{aligned}
$$
For the garage and basement features there are several features which indicate
the absence of that feature.
If one of them indicates the absence of a feature, the others should too.

```{r}
setdiff(which(full$BsmtCond == "noBasement"),
          which(full$BsmtExposure == "noBasement"))
setdiff(which(full$BsmtCond == "noBasement"),
          which(full$BsmtQual == "noBasement"))
full[c(2041, 2186, 2525), .(Id, BsmtCond, BsmtExposure, BsmtQual, 
                            BsmtUnfSF, TotalBsmtSF)]
```

So here the *data_description* is not consistent.
The general condition is set to *noBasement* but there are values
for basement exposure, quality, and so on.

```{r}
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageFinish == "noGarage"))
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageQual == "noGarage"))
setdiff(which(full$GarageType == "noGarage"),
          which(full$GarageCond == "noGarage"))
```

The garage features doesn't have these inconsistencies.

All dependencies are stored in a list.
For garage the feature *BsmtCond* is used as the reference since it seems to be
the most stringent one.

```{r}
featDeps <- list(
  BsmtCond = c("BsmtUnfSF", "TotalBsmtSF"),
  BsmtFinType1 = "BsmtFinSF1",
  BsmtFinType2 = "BsmtFinSF2",
  GarageType = c("GarageYrBlt", "GarageCars", "GarageArea"),
  PoolQC = "PoolArea",
  MiscFeature = "MiscVal",
  MasVnrType = "MasVnrArea"
)
```

## Missing Data

$NA$ which are left must be true missing data.
The following table gives a complete summary of missing data.

```{r}
naFeats <- vapply(
  colnames(full),
  function(j) any(is.na(full[[j]])) || any(full[[j]] == ""),
  logical(1)
)
md.pattern(full[, colnames(full)[naFeats], with = FALSE])
```

The total number of missing values per feature will be saved.
The features with at least one missing value are shown below.

```{r, warning=FALSE}
mdpat <- md.pattern(full[, -ncol(train), with = FALSE])
total <- mdpat[nrow(mdpat), -ncol(mdpat)]
featAttr$missing <- total[match(featAttr$name, names(total))]
dt <- featAttr[missing > 0, ]
dt$name <- factor(dt$name, levels = dt$name[order(dt$missing)])
ggplot(dt, aes(x = name, y = missing, fill = type)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Features with Missing Values")
```










***











# Feature Exploration




## Continuous and Discrete Features

### Feature Distributions

The following table gives a descriptive overview about continuous and discrete
feature distributions.
Besides the range and averages of variables, the relative difference between
mean and median is given as an indicator of the skewness.
In addition the relative cardinality and the abundance of outliers are given.

```{r}
m <- apply(full[, c(contVars, discVars), with = FALSE], 2,
      function(j) summary(j)[c(1, 3, 4, 6)])
cards <- apply(full[, c(contVars, discVars), with = FALSE], 2, 
               function(j) length(unique(j)) / length(j))
outs <- apply(full[, c(contVars, discVars), with = FALSE], 2, 
              function(j) length(boxplot.stats(j)$out) / length(j))
dt <- data.table(t(m))
dt$relDelta <- round((dt$Mean - dt$Median) / dt$Mean, 2)
dt$relCard <- round(cards, 2)
dt$relOuts <- round(outs, 2)
rownames(dt) <- c(contVars, discVars)
dt$type <- rep(c("cont", "disc"), c(length(contVars), length(discVars)))
DT::datatable(dt, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle(
    'relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'relCard', 
    color = styleInterval(c(0.2, 0.6), c('red', 'orange', 'green'))
  ) %>%
  formatStyle(
    'relOuts', 
    color = styleInterval(c(0.05, 0.1), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'type', 
    color = styleEqual(unique(dt$type), c('orange', 'blue'))
  )
```

In *GarageYrBlt* the maximum value is 2207, which does not make sense.
It seems that this is a type and the real value is 2007.
After checking that there are not more values above 2010
2207 is changed to 2007.

```{r, results='hide'}
full[GarageYrBlt == 2207, GarageYrBlt := 2007]
```

There are a lot of continuous features with low cardinality and a high
difference between mean and median.
All these variables have a median of 0.
Some of these variables are dependent on other categorical variables, 
so it is plausible that they are sparse.







### Correlatio between Features

The Pearson Correlation Coefficient is calculated for all feature pairs
where both features are discrete or continous.
The results are shown as heatmap below.
Using euclidean distance of the correlation matrix as a metric 
rows and columns were hierarchically ordered (complete link).

```{r, fig.width=10, fig.height=10}
m <- cor(
  full[, c(contVars, discVars), with = FALSE],
  use = "complete.obs"
)
corrplot(m, method = "color", order = "hclust")
```

Some clusters are visible.
The same hierarchical clustering is shown as tree below.

```{r}
corrClust <- hclust(dist(m))
plot(corrClust)
```


### Correlation to Target

For all continuous and discrete features the pearson correlation coefficient
to the target *SalePrice* is calculated.
Results are ordered by correlation.
The color labels the feature type, continuous or discrete.

```{r, fig.width=10, fig.height=5}
train <- full[label == "train", !"label", with = FALSE]
cors <- vapply(
  c(contVars, discVars),
  function(i) cor(train[[i]], train$SalePrice, use = "complete.obs"),
  numeric(1)
)
df <- data.frame(
  var = factor(c(contVars, discVars),
               levels = c(contVars, discVars)[order(cors)]),
  cor = cors,
  type = rep(c("cont", "disc"), c(length(contVars), length(discVars)))
)
ggplot(df, aes(x = var, y = cor, fill = type)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("P Correl Coeff of Cont+Discr Features vs SalePrice")
```








## Categorical Features

### Feature Distributions

As an overview of nominal and ordinal features their 
categorical distribution is described.
The table below summarizes range and averages, as well as the relative
difference between mean and median (*relDalta*).

```{r}
m <- apply(full[, c(ordVars, nomVars), with = FALSE], 2, 
           function(j) summary(as.vector(table(j)))[c(1, 3, 4, 6)])
dt <- data.table(t(m))
dt$relDelta <- round((dt$Mean - dt$Median) / dt$Mean, 2)
dt$type <- rep(c("ord", "nom"), c(length(ordVars), length(nomVars)))
rownames(dt) <- c(ordVars, nomVars)
DT::datatable(dt, options = list(dom = "t", pageLength = 40)) %>% 
  formatStyle(
    'relDelta', 
    color = styleInterval(c(0.2, 0.8), c('green', 'orange', 'red'))
  ) %>%
  formatStyle(
    'type', 
    color = styleEqual(unique(dt$type), c('orange', 'blue'))
  )
```

For most variables there is a big difference in the frequency of
classes that can occur.
There is no feature where a class can be completely excluded, 
but there are some features which have classes with only one representation.

### Correlation between Features

The Cramer's V is calculated for all feature pairs
where both features are categories.
The results are shown as heatmap below.
Using euclidean distance of the correlation matrix as a metric 
rows and columns were hierarchically ordered (complete link).

```{r, fig.width=10, fig.height=10, warning=FALSE}
m <- as.matrix(full[, c(ordVars, nomVars), with = FALSE])
m <- m[complete.cases(m), ]
mCramer <- vapply(
  seq_len(ncol(m)),
  function(i) {
    vapply(
      seq_len(ncol(m)),
      function(j) {
        assocstats(table(m[, i], m[, j]))$cramer
      },
      numeric(1)
    )
  },
  numeric(ncol(m))
)
colnames(mCramer) <- colnames(m)
rownames(mCramer) <- colnames(m)
corrplot(mCramer, method = "color", order = "hclust")
```

The same hierarchical clustering is shown as tree below.

```{r}
corrClust <- hclust(dist(mCramer))
plot(corrClust)
```

### Correlation to Target

For all categorical features the Kruskal-Wallis $\chi^2$ statistic
to the target *SalePrice* is calculated.
Results are ordered by the $\chi^2$ value.
The color labels the feature type, nominal or ordinal.

```{r, fig.width=10, fig.height=5, warning=FALSE}
kwX2 <- vapply(
  c(ordVars, nomVars),
  function(j) { kruskal.test(train$SalePrice, train[[j]])$statistic },
  numeric(1)
)
df <- data.frame(
  var = factor(c(ordVars, nomVars),
               levels = c(ordVars, nomVars)[order(kwX2)]),
  kwX2 = kwX2,
  type = rep(c("ord", "nom"), c(length(ordVars), length(nomVars)))
)
ggplot(df, aes(x = var, y = kwX2, fill = type)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("KW-X^2 for Categories vs SalePrice")
```







***

